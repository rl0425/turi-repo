# 코딩 컨벤션

코딩 컨벤션은 읽고, 관리하기 쉬운 코드를 작성하기 위한 일종의 코딩 스타일 규약입니다.
아래 나오는 내용들은 저희가 사용하는 코딩 컨벤션이고, 아웃풋을 추출할 때 해당 코딩 컨벤션을 잘 지켜주세요.

내가 코드를 만들어달라고 할때는, 아래의 규칙들을 일단 지켜줘.

깔끔한 디자인, 훌륭햔 ux/ui로 이기는게 목적이야. 일단 웹 기반으로 개발을 하고, 앱은 React Native로
바꿔줄 예정이거든? 그럼 이제 내가 앞으로 부탁할때, 반응형같은 모바일환경에서의 디자인도 고려를 해줘야겠지? 자 이걸 베이스로 하고
밑에는 상세한 규칙들이야.

아 맞다. 기술은 어떤걸 쓸거냐면,
일단 펑션기반으로, 타입스크립트로 작성해줘.
그리고 ci/cd는 깃허브 액션으로 해줘. 테스팅은 테스트코드를 작성할건데, 이걸 ci/cd에서 자동화 로직을 넣고싶어 마지막에.

자 밑에 잇는 기술스택들 전부와 컨벤션을 따르고, 내가 구현해야할 건 아래와 같아.

# 구현리스트

## 주요 기능 상세 설명

### 맞춤형 검색 시스템

검색 시스템은 단순한 필터링을 넘어 사용자의 생활 환경과 선호도를 고려한 맞춤형 추천 시스템으로 확장됩니다. 주거 환경, 라이프스타일, 경제적 상황 등을 종합적으로 고려하여 최적의 반려동물을 추천합니다. Next.js의 API 라우트와 Supabase의 강력한 쿼리 기능을 활용하여 복잡한 필터링 로직을 효율적으로 구현합니다.

### 가상 케어 시스템

실제 반려 생활을 시뮬레이션하는 이 시스템은 Zustand의 상태 관리와 React Query의 실시간 데이터 동기화를 활용하여 구현됩니다. 사용자는 다음과 같은 시나리오를 체험할 수 있습니다:

- 심야 시간대 산책 필요성 알림
- 갑작스러운 수의사 방문 상황
- 분리불안 증상 대처 시뮬레이션
- 예상 지출 관리 및 경고
- 일상적인 케어 루틴 체험

이러한 시나리오들은 TypeScript의 타입 시스템을 활용하여 안정적으로 구현되며, Tailwind CSS를 통해 직관적인 UI로 제공됩니다.

## 수익 모델 상세

### 맞춤형 광고 플랫폼

PawWise의 광고 시스템은 단순한 배너 광고를 넘어서는 데이터 기반의 타겟팅 플랫폼입니다:

- **사용자 행동 기반 광고**
    - React Query와 Zustand를 활용한 사용자 행동 데이터 수집
    - 관심 동물 종류, 검색 패턴, 지역 등을 고려한 맞춤형 광고 제공
    - 광고 효과 측정을 위한 상세한 분석 대시보드 제공
- **제휴사 네트워크**
    - 반려동물 용품 브랜드
    - 동물병원 체인
    - 펫 보험사
    - 전문 훈련소

### 제휴 수수료 시스템

입양 연계 및 관련 서비스 제공을 통한 수수료 수익 창출:

- **입양 연계 수수료**
    - 보호소 협력 프로그램 (MVP 단계)
    - 우수 펫샵 인증 프로그램 (Phase 2)
    - 입양 성공 시 수수료 정산 시스템
- **부가 서비스 연계**
    - 펫 보험 가입 시 수수료
    - 전문 훈련 서비스 연계
    - 동물병원 예약 시스템

### 프리미엄 컨텐츠

고품질 교육 컨텐츠를 통한 수익 창출:

- **전문가 제작 컨텐츠**
    - 행동 교정 가이드
    - 건강 관리 매뉴얼
    - 응급 상황 대처법
    - 품종별 특성 가이드


//
## 개발 로드맵

### Phase 1 (MVP)

- **기본 기능 구현**
    - 보호소 데이터 연동 시스템
    - 기본 검색 및 필터링
    - 간단한 가상 케어 알림
    - 사용자 인증 시스템
- **핵심 UI/UX 개발**
    - 반응형 디자인 구현
    - 기본 검색 인터페이스
    - 동물 프로필 페이지
    - 가상 케어 대시보드

### Phase 2 (확장)

- **기능 고도화**
    - AI 기반 매칭 시스템
    - 고급 검색 필터
    - 실시간 채팅 시스템
    - 결제 시스템 연동
- **데이터 분석 시스템**
    - 사용자 행동 분석
    - 입양 성공률 추적
    - 광고 효과 측정

### Phase 3 (최적화)

- **서비스 안정화**
    - 성능 최적화
    - 보안 강화
    - 에러 추적 시스템
    - 백엔드 스케일링
- **커뮤니티 기능**
    - 사용자 후기 시스템
    - 입양 성공 스토리
    - 실시간 Q&A


### 모니터링 및 분석

- Vercel Analytics를 통한 성능 모니터링
- Sentry를 통한 에러 추적
- Google Analytics를 통한 사용자 행동 분석

## 확장 가능성

### 국제화 지원

- i18n을 통한 다국어 지원 준비
- 해외 보호소 연동 가능성
- 글로벌 반려동물 입양 문화 기여

### AI 통합

- 동물 행동 패턴 분석
- 최적 매칭 알고리즘
- 예측 기반 케어 가이드

이 프로젝트는 단순한 입양 플랫폼을 넘어, 책임있는 반려동물 문화를 만들어가는 혁신적인 서비스를 지향합니다. 기술적 완성도와 사회적 가치를 동시에 추구하며, 지속 가능한 비즈니스 모델을 통해 장기적인 성장을 도모합니다.

### Database

- Supabase

### State Management

- Zustand
- React Query

### Styling

- Tailwind CSS
- shadcn

### Testing

- Jest
- React Testing Library
- Cypress

### Package Management

- pnpm 사용

### Version Management

- Git / Github
- CI/CD
- github actions
- vercel

### API Connection

- REST API

### Design Tools

- Figma

### ETC

- ESLint
- Prettier
- Storybook
- Next.js App router
- React Native

### Library

- framer-motion ( 애니메이션 )
- shadcn ( 컴포넌트 )

이렇게 쓸거야!


## 기본 규칙 1
이게 가장 중요한 규칙들인데, 이 규칙들을 모든 규칙중에서 가장 우선순위를 높여주면 될 것 같아.
1) 모든 구조는 객체 구조 지향적으로 짜되, 내가 질문이나 항의할때 객체구조 지향적이지 않은 걸 물어보거나 얘기한다면 객체 지향 구조의 어떠한 부분이기 때문에 
그렇게 해서는 안된다 또는 그렇게 할수 없다고 말해주면 될 것 같아.
2) 모든 자바스크립트 코드는 SOLID 원칙을 엄격하게 준수해야한다. solid 원칙이 적용되지 않는 파일이나 구조같은 경우에는 이러한 특징을 무조건 언급해야 한다.
3) 성능 최적화 (useCallback, memo 사용) 를 신경써, 필요한 부분에 삽입한다.
4) 접근성 강화 (aria-label, role 추가) 를 신경써, 필요한 부분에 삽입한다.
5) 에러 처리 강화 (로딩/에러 상태 처리) 를 신경써, 필요한 부분에 삽입한다.
6) 사용자 피드백 개선 (로딩 상태, 연속 클릭 방지) 를 신경써, 필요한 부분에 삽입한다.
7) 프로젝트 자체를 MVVM 패턴으로 짤거야. 그리고 그렇게 너가 짜주고, 어떤 부분이 MVVM의 특성이나 특징인지도 다 설명해주면 돼.
8) 내가 어떤 코드를 만들어달라고 할때, 폴더링을 신경써줘. 위나 아래의 컨벤션에 맞춘 폴더링을 너가 적합한걸 몇개 추천해주거나, 알맞게 적용을 해줬으면 좋겠어
9) 모든 컴포넌트나 css는 일단 미리 만들어놓은 shadcn을 이용해야돼. 이용하는 법은 밑에 컨벤션을 적어놨어.

## 기본 규칙 2

1) 타입스크립트 최적화 -> 타입 명시화나 인터페이스, 타입 등, 추론을 최적화해서 구체적으로 작성법
2) 성능 최적화 -> useCallback, useMemo, useEffect 등 성능 최적화 함수 사용 -> 여러 개의 useState를 하나의 객체로 
통합 하는 드으이 상태 업데이트 등, 모든 면에서 최적화를 생각해서 작성해줘.
3) 코드 구조 개선 -> 각종 varient를 상수로 분리하거나, JSDoc을 사용해서 컴포넌트와 인터페이스에 대한 문서화, 또 불필요한
Import나 코드를 없애는 등의 전문적이고 깔끔한 코드의 구조를 생각해줘
4) 스타일링 최적화 -> 인라인 스타일과 클래스네임을 분리하여 가독성을 향상시키고, 동적 스타일은 useMemo를 사용해서 최적화해줘.
5) 접근성 개선 -> aria-label과 aria-live 속성 추가, 헤더 역할을 하는 요소에 role="heading" 추가, 클릭 가능한 요소에 role="button" 추가
6) 상수 관리 -> 매직 넘버 제거 및 상수화, 애니메이션 관련 값들을 중앙 집중화, 애니메이션 관련 값들을 중앙 집중화
7) Tailwind CSS 사용 시 주의사항 -> Tailwind CSS의 JIT 모드에서는 동적으로 생성된 클래스가 사전에 정의되어 있어야 하므로, 
상수로 선언된 값을 사용하여 스타일을 적용하는 방식은 피하고, 직접 Tailwind CSS 유틸리티 클래스를 사용하는 것을 지향한다.

## 외부 라이브러리

라이브러리를 설치할 경우에는 Package Manager를 npm을 기반으로 사용합니다.

## 폴더링

라우터별 폴더링 방식을 차용합니다.

- 라우터를 기능별로 폴더링합니다. > fsd 원칙을 따릅니다.
- 기능 별로 나누어진 폴더에서 페이지들의 폴더를 각각 생성한 후에 해당 위치에 레이아웃 파일 및 공통 파일을 넣습니다.
  예) /src/app/graph/page.tsx, /src/app/graph/components, /src/app/graph/styles
- 프로젝트 전체에 필요한 컴포넌트나 styles, util, lib, hooks 파일은 src 폴더 최상단에 위치합니다.
  예) /src/app, /src/components, /src/hooks, /src/lib
- 프로젝트 전체에 사용되는 공통 컴포넌트는 /src/components/common에 위치합니다.
- 라이브러리 관련 컴포넌트 및 함수는 /src/lib 폴더에 위치합니다.
- API 호출 관련 함수나 외부 서비스와의 통신을 담당하는 코드/데이터 패칭 로직은 /src/services 폴더에 위치합니다.
- 여러 곳에서 재사용 가능한 유틸리티 함수/날짜 포맷팅, 수학 연산 등의 헬퍼 함수 혹은 공통으로 사용되는 상수나 타입을 /src/utils 폴더에 위치합니다.

## 타입스크립트

- type과 interface를 명명할 때 Pascal Case를 사용합니다.
- 객체 형태는 Interface를 사용하고 그 외는 type을 사용합니다.

## 스타일링

스타일링은 Tailwind을 사용합니다.

- 클래스 순서는 레이아웃 -> 타이포그래피 -> 시각적 스타일 -> 기타 순으로 정렬합니다.
  예) class="flex items-center p-4 text-lg font-bold text-blue-500 hover:bg-gray-100"
- 반응형 클래스 순서는 아래 예시와 같습니다.
  예) class="w-full sm:w-1/2 md:w-1/3 lg:w-1/4"
- 상태 관련 클래스(hover, focus 등)는 일반 클래스 뒤에 배치합니다.
  예) class="text-white bg-blue-500 hover:bg-blue-600 focus:ring-2"
- 자주 사용하는 클래스 조합은 @apply 디렉티브를 사용하여 커스텀 클래스를 만듭니다.
  예) @layer component { .btn-primary { @apply px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600;} }
- 관련된 클래스들은 괄호로 그룹화하여 가독성을 향상시킵니다.
  예) class="(flex items-center justify-between) (p-4 m-2) (text-lg font-bold)"
- 조건부 클래스 적용을 위해 clsx나 classnames 같은 유틸리티 함수를 사용합니다.
  예) <div className={clsx('base-class'), isActive && 'active_class', isDisabled && 'disabled-class')} />

## 네이밍 컨벤션

- 불필요한 줄임말을 사용하지 않고 명확한 네이밍을 사용합니다.
- 변수는 기본적으로 카멜 케이스를 사용합니다.
  예) isActive, myProfile
- 상수는 영문 대문자 스네이크 케이스를 사용합니다.
  예) SNAKE_CASE, TOTAL_MEMBER, LIMIT
- 데이터가 boolean 타입일 경우 prefix로 is를 사용합니다.
  예) isLoggedIn, isOpen
- 변수에 할당되는 값이 배열일 경우 복수형 이름을 사용합니다
  예) users, members
- 컴포넌트 네이밍은 파스칼 케이스를 사용합니다.
  예) function FuncName(){...}
- 이벤트 핸들러는 props인 경우 on + 이벤트명, 함수인 경우 handle + 함수명(이벤트)을 사용합니다.
  예) onSubmit, handleForm
- 컴포넌트의 property는 camelCase를 사용합니다.
  예) <Foo userName="1234" phoneNumber="14444" />

## 컴포넌트 순서

1. 변수를 가장 위에 선언합니다.
2. 변수 중에서도 state를 상위에 둡니다.
3. 그 다음 handler 등 함수를 선언합니다.
4. 그 다음 useEffect를 선언합니다.
5. 마지막으로 return을 선언합니다.

## 주석 사용

주석을 사용하는 경우 JSDoc 문법을 사용합니다.
특히, 컴포넌트 및 훅 단위에는 반드시 파라미터에 대한 주석을 작성해주어야 합니다.

- 변수 작성법

```tsx
/**
 * 과일 타입
 * @type {'Apple' | 'Banana' | 'Orange'}
 */
const fruit = 'Apple';
```

- 함수 작성법

```tsx
/**
 * 토스트 메세지 띄우는 함수
 * @param {object} props
 * @param {string} props.message 토스트 메세지
 */
const onInitToast = ({ message }) => {
  ...
}
```

- 컴포넌트 및 훅 단위에는 반드시 파라미터에 대한 주석을 작성합니다.

```tsx
/**
 * 컴포넌트명
 * @param {object} props
 * @param {string} props.foo foo에 대한 설명
 * @param {number} props.bar bar에 대한 설명
 */
const Component = ({ foo, bar }) => {
  return <div> ... </div>;
};

export default Component;
```

- 유틸 및 api 단위에는 함수별로 주석을 작성합니다.

```tsx
/**
 * 덧셈 함수
 * @param {number} a
 * @param {number} b
 */
const add = (a, b) => a + b;

/**
 * 곱셈 함수
 * @param {number} a
 * @param {number} b
 */
const multiply = (a, b) => a * b;
```


- **✨ shadcn/ui lib**
    
    **( 24/10/22 추가 )**
    
    - https://ui.shadcn.com/ doc 참조 및 사용
    - `.cursorrules` convention 삽입
    - `Cursor ai` 사용 시 현재 기본적으로 `shadcn/ui` 컴포넌트가 있다면 해당 컴포넌트를 우선적으로 사용 조치 (JSX)
    - 해당 라이브러리(`shadcn/ui`)에 적절한 컴포넌트가 없는 경우에만 `HTML 시맨틱 태그` 혹은 `공통 컴포넌트`를 사용
    - 새로운 컴포넌트 추가 시 `src/components/ui` 에 삽입 후, 해당 폴더 `index.ts`에 필수적으로 `export` 추가
    - `shadcn/ui` 컴포넌트를 `import`할 때는 가능한 한 줄로 작성
        
        ```
        import { Button, Card, Input } from '@/components/ui';
        ```
        
    - 단, `import` 문이 너무 길어져 가독성이 떨어지는 경우에는 여러 줄로 나누어 작성
        
        ```
        // 한 줄로 작성했을 때 가독성이 떨어지는 경우
        import { Button, Card, Input, Label, Checkbox, RadioGroup, RadioGroupItem, Select, SelectContent, SelectItem, SelectTrigger, SelectValue, Slider, Switch, Textarea, Toast, Tooltip } from '@/components/ui';
        
        // 여러 줄로 나누어 작성한 경우
        import {
          Button,
          Card,
          Input,
          Label,
          Checkbox,
          RadioGroup,
          RadioGroupItem,
          Select,
          SelectContent,
          SelectItem,
          SelectTrigger,
          SelectValue,
          Slider,
          Switch,
          Textarea,
          Toast,
          Tooltip
        } from '@/components/ui';
        ```
        
- **✨ 폴더링**
    - 라우터별 폴더링 방식 차용
        
        [image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/3ad70e1c-3e4f-43fd-bd1a-18d21d1d5cb9/Convention_1180903da32380b183b0c87460a2a21bimage.png)
        
        - 라우터를 카테고리(`auth`, `communtiy`, `grpah`)나 기능별로 폴더링
        - 카테고리 별로 나누어진 폴더에서, 페이지들의 폴더를 각각 생성 후에 해당 위치에 레이아웃 파일 및 공통 파일을 삽입
            
            [image 1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/6a773abe-62ae-4c6c-90ae-7646d2bde119/Convention_1180903da32380b183b0c87460a2a21bimage_1.png)
            
        - 기능이나 페이지를 추가/확장하는 경우 폴더 위치를 파일의 성질(기능)에 따라 위치
            - ex. 회원가입, 로그인 기능을 하는 파일들은 `(auth)` 폴더에 삽입
            
            [image 2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/ff9d7544-e416-437e-9fd9-2268819e3b38/Convention_1180903da32380b183b0c87460a2a21bimage_2.png)
            
        - 프로젝트 전체에 필요한 컴포넌트나 `styles`, `utill`, `lib`, `hooks` 파일은 `src` 폴더 최상단에 위치
            
            [image 3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/8049906e-f24a-4dfe-b6fb-34d8afc1fb15/Convention_1180903da32380b183b0c87460a2a21bimage_3.png)
            
            - 이 외에도, 프로젝트 전체에 사용되는 파일들은 이 규칙을 따름 (ex. services files, stories files)
        - 프로젝트 전체에 사용되는 공통 컴포넌트(`Button`, `Modal`, `Dropdown` …) 는 `src/components/common`에 위치
        - 라우팅 페이지 별로 사용되는 공통 컴포넌트는 각 카테고리 폴더(`auth`, `community`..)안에 위치
        - 라이브러리 관련 컴포넌트 및 함수는 `lib` 폴더에 위치
        - API 호출 관련 함수나 외부 서비스와의 통신을 담당하는 코드/데이터 패칭 로직은 `services` 폴더에 위치
            
            [image 4.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/639d1f80-5d59-4894-9599-4d7b3e849c5c/Convention_1180903da32380b183b0c87460a2a21bimage_4.png)
            
        - 여러 곳에서 재사용 가능한 유틸리티 함수/날짜 포맷팅, 수학 연산 등의 헬퍼 함수/ 공통으로 사용되는 상수나 타입은 `utils` 폴더에 위치
            
            [image 5.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/d04dc274-2053-4749-8de0-d8daff8ac452/Convention_1180903da32380b183b0c87460a2a21bimage_5.png)
            
- **✨ 타입스크립트**
    - `type`, `interface`
        - 명명 시 `Pascal Case`를 사용
        - `interface`와 `type`을 혼용해서 사용
        - 객체 형태는 `Interface`를 사용
        - 유니온 타입, 교차 타입, 타입 별칭 등은 `type`을 사용
        - 보통의 경우엔 `interface`를 지양
        
        [image 6.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/42c7897d-f6cf-490b-bae0-f51634de67b6/Convention_1180903da32380b183b0c87460a2a21bimage_6.png)
        
    - 열거형 방식
        - 연속된 숫자 및 상수 리터럴일 경우, 열거형 방식을 지양 ( 숫자, 문자)
        
        [image 7.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/c63eca1e-1436-4950-b080-9bbd7e6679a4/Convention_1180903da32380b183b0c87460a2a21bimage_7.png)
        
    - `Generic` 사용 규칙 (미정)
        - 추후에 서술
- **✨ Tailwind**
    - 클래스 순서
        - 레이아웃 → 타이포그래피 → 시각적 스타일 → 기타 순으로 정렬
        
        ex. `class="flex items-center p-4 text-lg font-bold text-blue-500 hover:bg-gray-100"`
        
    - 반응형 클래스 순서
        - 모바일 퍼스트 접근: 기본 클래스 → sm → md → lg → xl → 2xl
        
        ex.  `class="w-full sm:w-1/2 md:w-1/3 lg:w-1/4"`
        
        [image 8.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/7082ec41-ce88-40c3-a4c7-757f7ed96641/Convention_1180903da32380b183b0c87460a2a21bimage_8.png)
        
    - 상태 클래스 위치
        - 상태 관련 클래스(hover, focus 등)는 일반 클래스 뒤에 배치
        
        ex. `class="bg-blue-500 text-white hover:bg-blue-600 focus:ring-2"`
        
    - 커스텀 클래스 사용
        - 자주 사용되는 클래스 조합은 @apply 디렉티브를 사용하여 커스텀 클래스로 만들기
        
        [image 9.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/fa126a1a-46a5-45d8-91f4-a9973e5e983c/Convention_1180903da32380b183b0c87460a2a21bimage_9.png)
        
    - 클래스 그룹화
        - 관련된 클래스들을 괄호로 그룹화하여 가독성 향상
        
        ex. `class="(flex items-center justify-between) (p-4 m-2) (text-lg font-bold)"`
        
    - 긴 클래스 문자열 처리
        - 여러 줄로 나누어 작성하거나 템플릿 리터럴 사용
        
        [image 10.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/787da960-4596-4cd6-8736-ffe3b1459426/Convention_1180903da32380b183b0c87460a2a21bimage_10.png)
        
    - 유틸리티 함수 사용
        - 조건부 클래스 적용을 위해 clsx나 classnames 같은 유틸리티 함수 사용
        
        [image 11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/74fd1ae8-4a2f-42da-98fb-a27385b5f223/Convention_1180903da32380b183b0c87460a2a21bimage_11.png)
        
    - 명명 규칙
        - 커스텀 클래스나 컴포넌트 이름에 일관된 접두사 사용 (예: `btn-`, `card-`)
        - 주석 사용
            - 복잡한 클래스 조합에는 주석을 달아 의도 설명
    - **[Tailwind CSS IntelliSense, Headwind] extension tool 사용 권고**
- **✨ 에러 및 로딩, 빈 페이지 컴포넌트 구분**
    
    `app` 라우터 방식 및 `nextjs`의 장점을 극대화하기 위한 컨벤션
    
    - 기본적인 레이아웃 페이지는 각 라우팅 폴더에 `layout.tsx` 형태로 삽입
    - 로딩 페이지는 각 라우팅 폴더에 `loading.tsx` 형태로 삽입 후 `<Suspense>` 태그를 사용
    - 에러 페이지는 각 라우팅 폴더에 `error.tsx` 형태로 삽입
    - 404 페이지는 각 라우팅 폴더에 `not-found.tsx` 형태로 삽입
    
    [image 12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7f1f69d-b921-4878-a825-7a578ba94a14/c4d49f02-810b-4291-b72f-f595462573b7/Convention_1180903da32380b183b0c87460a2a21bimage_12.png)
    
- **✨ 네이밍 컨벤션**
    
    ### 🐣 기본
    
    - 불필요한 줄임말 사용하지 않기 (명확한 네이밍 사용)
    
    ### 🐣 변수
    
    - 기본적으로 카멜 케이스 `camelCase`
    - 상수 - 영문 대문자 스네이크 케이스 `SNAKE_CASE`
    - 데이터가 `boolean` 타입일 경우 `is~` prefix
    - 변수에 할당되는 값이 배열일 경우 복수형 이름을 사용 `users`
    - 🐣 **컴포넌트**
        - 파스칼케이스 `PascalCase`
            - `function FuncName() { ... }`
        - 확장자 `tsx`
            
            ### 🐣 컴포넌트 순서
            
            ```
            /* 1. 변수를 가장 위에 선언
             * - 변수 중에서도 state를 상위에 둡니다. */
            const [state, setState] = useState();
            const inputRef = useRef();
            const variable = "기타 변수";
            
            /* 2. handler 등 함수 선언 */
            const handleClick = () => {};
            
            /* 3. useEffect */
            useEffect(()=>{}, []);
            
            return <> ... </>
            ```
            
            - useState 변수 핸들함수 useEffect return 순서
    - 🐣 **함수**
        - 카멜 케이스 `camelCase`
            - 유틸 함수, 내부 핸들러 함수 등은 화살표 함수 사용`const funcName = () => { ... }`
            
            ```
            [X]
            const foo = function() { ... }
            
            [O]
            const foo = () => { ... }
            ```
            
            - Arrow 함수는 짧고 한 줄로 끝이나는 경우, 중괄호를 작성하지 않고 작성합니다. 또한, return문을 포함하여 구문이 1개일 경우, return문을 생략하여 작성합니다.
                
                ```
                [X]
                const foo = () => {
                  return 6;
                }
                
                [O]
                const foo = () => 6;
                ```
                
        - 커스텀 훅은 `use+함수명`
        - 이벤트 핸들러는 Props인 경우 `on+이벤트`, 함수인 경우 `handle+함수명(이벤트)`
        - `arguments` 를 지양하고, 전개구문을 사용합니다.
            
            ```
            [X]
            const foo = (arguments) => {
              return arguments;
            }
            
            [O]
            const foo = (...args) => {
              return args;
            }
            ```
            
        - 함수의 파라미터는 조작하지 않습니다.
            
            ```
            [X]
            const foo = (cnt) => {
              cnt += 1;
              return cnt;
            }
            
            [O]
            const foo = (cnt) => {
              const count = cnt + ;
              return count;
            }
            ```
            
    - 🐣 **객체**
        - 기본적으로 빈 객체 선언은 리터럴로 작성합니다.
            
            ```
            [X]
            const foo = new Object();
            
            [O]
            const foo = {};
            ```
            
        - 객체에 Property를 추가할 때에는 직접적으로 변경하는 것보다 `.assign` 문법을 통해서 변경&생성하는 것을 지향합니다.
            
            ```
            const foo = {};
            
            [X]
            foo.name = "foo";
            foo["name"] = "foo";
            
            [O]
            const bar = Object.assign(foo, { name: "foo" });
            ```
            
        - 깊은 객체 사용을 지양합니다. 가능한 한 객체는 얇게 유지합니다.
            
            만약 불가피하게 깊은 객체를 유지해야할 경우, 선언을 분리시켜서 가독성이 좋게 작성합니다.
            
            ```
            [X]
            const foo = {
              animals: {
                dog: { ... },
                cat: { ... }
              },
              universe: {
                sun: { ... },
                earth: { ... },
              }
            }
            
            [O]
            const dog = { ... };
            const cat = { ... };
            const animals = { dog, cat };
            
            const sun = { ... };
            const earth = { ... };
            const universe = { sun, earth };
            
            const foo = { animals, universe };
            ```
            
    
    ### 🐣 폴더 구조
    
    - FSD 구조
    
    ### 🐣 속성
    
    - 카멜 케이스 `camelCase`
    - 명확한 `true` 값일 경우 값을 생략
        
        `<button disabled> 로그인 </disabled>`
        
        ```
        // bad
        <Foo
          UserName="hello"
          phone_number={12345678}
        />
        
        // good
        <Foo
          userName="hello"
          phoneNumber={12345678}
        />
        
        // bad
        <Foo
          hidden={true}
        />
        
        // good
        <Foo
          hidden
        />
        ```
        
- **✨ 주석**
    
    ### 🐣 JSDoc 용법
    
    - 변수 작성법
        
        ```
        /**
         * 과일 타입
         * @type {'Apple' | 'Banana' | 'Orange'}
         */
        const fruit = 'Apple';
        ```
        
    - 함수 작성법
        
        ```
        /**
         * 토스트 메세지 띄우는 함수
         * @param {object} props
         * @param {string} props.message 토스트 메세지
         */
        const onInitToast = ({ message }) => {
          ...
        }
        ```
        
    - 타입스크립트 파일 활용 작성법
        
        ```
        /**
         * 사용자 리뷰 타입 목록
         * @type {import('types/review').Review[]}
         */
        const reviewList = [];
        ```
        
    - 타입스크립트 interface, type
        
        ```
        TypeScript 타입 정의 가이드라인:
        1. 컴포넌트 props, 객체 형태의 타입: `interface` 사용
        2. 유니온 타입, 교차 타입, 타입 별칭: `type` 사용
        3. 클래스가 구현해야 하는 형태: `interface` 사용
        4. 복잡한 타입 조작이 필요한 경우: `type` 사용
        ```
        
    
    ### 🐣 컴포넌트 및 훅 주석
    
    - 컴포넌트 및 훅 단위에는 반드시 파라미터에 대한 주석을 작성합니다.
        
        ```
        /**
         * 컴포넌트명
         * @param {object} props
         * @param {string} props.foo foo에 대한 설명
         * @param {number} props.bar bar에 대한 설명
         */
        const Component = ({ foo, bar }) => {
          return <div> ... </div>;
        }
        
        export default Component
        ```
        
    
    ### 🐣 유틸 및 api 주석
    
    - 유틸 및 api 단위에는 함수별로 주석을 작성합니다.
        
        ```
        /**
         * 덧셈 함수
         * @param {number} a
         * @param {number} b
         */
        const add = (a, b) => a + b;
        
        /**
         * 곱셈 함수
         * @param {number} a
         * @param {number} b
         */
        const multiply = (a, b) => a * b;
        ```
        
- **✨ 포맷팅 룰**
    
    ### 🐣 ESLint / prettier
    
- **✨ Git 컨벤션**
    
    ### 🐣 브랜치 전략
    
    - `feat/이름-featureName`
        - `feat/minho-Nav`
    - bug fix: `fix/이름-내용`
    
    ### 🐣 커밋 / PR / 이슈
    
    - [커밋 종류]: [작업 내용] ([이슈 번호])
    eg)`feat: Auth context 훅 생성(#3)`
    - 커밋 종류는 소문자 사용
    
    ```
    // 주요
    feat 새로운 기능 추가
    fix 버그 수정
    docs 문서 수정, 추가
    test 테스트 코드 추가, 수정, 삭제
    refact 코드 리팩토링
    style 코드 의미에 영향을 주지 않는 변경사항 (코드 스타일, 포맷 수정, 줄 바꿈 등)
    design CSS 등 사용자 UI 디자인을 추가, 수정한 경우
    chore 빌드 부분 혹은 패키지 매니저 수정사항
    
    // 그 외
    add
    feat 이외의 부수적인 코드, 라이브러리 등을 추가한 경우
    새로운 파일(Component나 Activity 등)을 생성한 경우도 포함
    
    remove
    코드, 파일을 삭제한 경우, 필요 없는 주석 삭제도 포함
    
    move
    fix, refactor 등과 관계 없이 코드, 파일 등의 위치를 이동하는 작업만 수행한 경우
    
    comment
    필요한 주석을 추가, 수정한 경우(❗필요 없는 주석을 삭제한 경우는 remove)
    
    rename
    파일명 수정
    ```
    
    - PR 템플릿
        
        ```
        Title: [#이슈넘버] 제목
        e.g) [#27] feat: 유저 컴포넌트 제작
        
        ## Description
        [PR에 대한 설명을 적습니다.]
        
        ## Changes Made
        [변경사항 리스트를 적습니다.]
        
        ## Screenshots
        
        ## IssueNumber
        해당 이슈 넘버 ( #  )
        ```
        
    - issue 템플릿
        
        ```
        Title: 제목
        e.g) 유저 컴포넌트 구현
        
        ## 요약
        
        ## ToDo
        - []
        - []
        ```
        

---

추가 사항(24/10/14)

- SVG Sprit 네이밍 컨벤션
    - 파일 위치 - src/assets/sprites/SvgSprite.tsx
    
    ```
    /**
     * SVG 스프라이트 컴포넌트
     *
     * 아이콘 ID 컨벤션:
     * [페이지/컴포넌트]-[카테고리]-[구체적인 이름]
     *
     * 사용 가능한 아이콘 ID:
     * - main-nav-home: 메인 페이지 네비게이션용 홈 아이콘
     * - header-action-search: 헤더 컴포넌트의 검색 액션 아이콘
     * - modal-ui-close: 모달 컴포넌트의 닫기 UI 아이콘
     * - footer-social-facebook: 푸터의 페이스북 소셜 아이콘
     *
     * 사용 예:
     * <svg><use xlinkHref="#main-nav-home" /></svg>
     * <svg><use xlinkHref="#header-action-search" /></svg>
     */
    
    <svg xmlns="http://www.w3.org/2000/svg" style={{ display: 'none' }}>
      <symbol id="main-nav-home" viewBox="0 0 24 24">
        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
      </symbol>
    
      <symbol id="header-action-search" viewBox="0 0 24 24">
        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
      </symbol>
    </svg>
    
    // 사용예시
    
    기본 크기 사용 (24x24)
    <Icon name="main-nav-home" />
    
    크기 지정
    <Icon name="header-action-search" width={32} height={32} />
    
    문자열로 크기 지정
    <Icon name="modal-ui-close" width="1.5em" height="1.5em" />
    
    className을 통한 스타일링과 함께 사용
    <Icon name="footer-social-facebook" className="text-blue-500" width={20} height={20} />
    ```
    
- 중복 로케이션 찾기 툴
    
    ```
    import { fileURLToPath } from 'url';
    import path from 'path';
    import fs from 'fs';
    
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    
    const srcDir = path.join(__dirname, 'src'); // 실제 소스 코드 디렉토리로 수정하세요
    
    function getEffectiveRoutePath(fullPath) {
      return fullPath.split(path.sep)
        .filter(segment => !segment.startsWith('(') && !segment.endsWith(')'))
        .join('/');
    }
    
    function hasPageFile(dir) {
      const pageFiles = ['page.js', 'page.tsx', 'index.js', 'index.tsx'];
      return pageFiles.some(file => fs.existsSync(path.join(dir, file)));
    }
    
    function scanDirectory(dir, routes = {}, basePath = '') {
      if (!fs.existsSync(dir)) {
        console.error(`디렉토리가 존재하지 않습니다: ${dir}`);
        return routes;
      }
    
      const entries = fs.readdirSync(dir, { withFileTypes: true });
    
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const fullPath = path.join(dir, entry.name);
          const relativePath = path.relative(srcDir, fullPath);
          const effectivePath = getEffectiveRoutePath(relativePath);
          const fullEffectivePath = path.join(basePath, effectivePath);
    
          if (routes[fullEffectivePath]) {
            if (hasPageFile(fullPath) && hasPageFile(routes[fullEffectivePath])) {
              console.log(`라우팅 충돌 발견: ${fullEffectivePath}`);
              console.log(`  - ${routes[fullEffectivePath]}`);
              console.log(`  - ${fullPath}`);
            } else {
              console.log(`잠재적 중복 경로 (page 파일 없음): ${fullEffectivePath}`);
              console.log(`  - ${routes[fullEffectivePath]}`);
              console.log(`  - ${fullPath}`);
            }
          } else {
            routes[fullEffectivePath] = fullPath;
          }
    
          scanDirectory(fullPath, routes, fullEffectivePath);
        }
      }
    
      return routes;
    }
    
    const routes = scanDirectory(srcDir);
    console.log('라우트 검사 완료');
    ```
    
- node check-duplicate.mjs(파일명)으로 실행